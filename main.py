#!/usr/bin/env python
# docker run -it --rm --env-file .env -v /path/to/folder/atd-traffic-incident-reports:/app \
# atddocker/atd-traffic-incident-reports:production bash

import os
import logging
import sys
import requests
import cx_Oracle
import hashlib
import arrow


USER = os.getenv("USER")
PASSWORD = os.getenv("PASSWORD")
HOST = os.getenv("HOST")
PORT = os.getenv("PORT")
SERVICE = os.getenv("SERVICE")
PGREST_ENDPOINT = os.getenv("PGREST_ENDPOINT")
PGREST_TOKEN = os.getenv("PGREST_TOKEN")

headers = {
    "Content-Type": "application/json",
    "Authorization": f"Bearer {PGREST_TOKEN}",
    "Prefer": "return=representation, resolution=merge-duplicates",
}

QUERY = "SELECT * FROM QACT_USER.QACT"


def get_conn(host, port, service, user, password):
    # make connect descriptor string
    oracle_data_source_name = cx_Oracle.makedsn(host, port, service_name=service)
    # create and return oracle connection object
    return cx_Oracle.connect(user=user, password=password, dsn=oracle_data_source_name)


def get_oracle_db_records():
    conn = get_conn(HOST, PORT, SERVICE, USER, PASSWORD)
    cursor = conn.cursor()
    cursor.execute(QUERY)

    # define row handler which returns each row as a dict
    # h/t https://stackoverflow.com/questions/35045879/cx-oracle-how-can-i-receive-each-row-as-a-dictionary
    cursor.rowfactory = lambda *args: dict(
        zip([d[0] for d in cursor.description], args)
    )
    rows = cursor.fetchall()
    conn.close()

    logging.info(f"{len(rows)} records in oracle database received.")
    return rows


def generate_record_id(call_number, timestamp):
    """
    the records from the oracle database do not have record ids associated with them
    the coldfusion app added IDs generated by Coldfusion using #hash(call_number,"SHA")#
    this function does the same using hashlib and appending our timestamp as before
    :param call_number: call_number
    :param timestamp:
    :return: traffic_incident_id string
    """
    # create coldfusion hash id
    cf_id = hashlib.sha1(str.encode(call_number)).hexdigest().upper()
    #  compose record id from entry identifier (which is not wholly unique) and publication timestamp
    return "{}_{}".format(cf_id, timestamp)


def get_active_records():
    active_records_endpoint = f"{PGREST_ENDPOINT}?traffic_report_status=eq.ACTIVE"

    active_records_response = requests.get(active_records_endpoint, headers=headers)
    active_records_response.raise_for_status()
    return active_records_response.json()


def format_record(incident):
    record = {}
    published_date = arrow.get(incident['CURR_DATE']).replace(tzinfo="US/Central")
    status_date = arrow.now().format()
    record["traffic_report_id"] = generate_record_id(incident['CALL_NUMBER'], published_date.timestamp)
    record["published_date"] = published_date.format()
    record["traffic_report_status"] = "ACTIVE"
    record["traffic_report_status_date_time"] = status_date
    record["address"] = incident['ADDRESS'].strip()
    record["issue_reported"] = incident['DESCRIPTION'].strip()
    record["latitude"] = incident['LATITUDE']
    record["longitude"] = incident['LONGITUDE']
    return record


def parse_records(traffic_incidents):
    records = []
    for incident in traffic_incidents:
        record = format_record(incident)
        records.append(record)

    return records


def main():
    traffic_incident_records = get_oracle_db_records()
    traffic_incident_records = parse_records(traffic_incident_records)
    print(traffic_incident_records)
    active_records = get_active_records()
    # make a list of the record ids only
    active_records_ids = [record["traffic_report_id"] for record in active_records]
    print(len(active_records))
    print("DONE")


if __name__ == "__main__":
    logging.basicConfig(stream=sys.stdout, level=logging.INFO)
    main()
